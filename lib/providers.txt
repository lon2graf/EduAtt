1. «Вечные» (Авторизация)

Эти провайдеры хранят состояние, пока пользователь не нажмет "Выйти".

    currentStudentProvider / teacherProvider

        Когда наполняется: В момент нажатия кнопки «Войти» (loginScreen).

        Когда обновляется: Никогда (в рамках сессии данные студента/учителя редко меняются).

        Когда очищается:

            Только при вызове метода .logout().

            Это происходит, когда ты нажимаешь кнопку «Выйти» в профиле. Состояние сбрасывается в null.

2. «По запросу» (Главный экран и Статистика)

Эти данные нужны нам часто, мы их обновляем, но не удаляем при каждом уходе с экрана, чтобы не было черных дыр при возврате.

    currentLessonProvider (Текущая пара)

        Когда загружается:

            Сразу при входе в приложение (в StudentLoginScreen после успешного логина).

            При свайпе вниз (RefreshIndicator) на Главном экране.

            После нажатия кнопки «Сохранить» в ведомости (чтобы обновить статус кнопки "Отметить").

        Когда очищается: Не очищается явно, просто перезаписывается новым значением при следующем обновлении.

    attendanceProvider (История пропусков)

        Когда загружается:

            При входе в приложение.

            При свайпе вниз (RefreshIndicator) на Главном экране.

            При свайпе вниз на экране «Посещаемость» (MissesContentScreen).

        Когда очищается: Не очищается, перезаписывается.

3. «Временные / Транзакционные» (Процесс отметки)

Самая хитрая часть. Здесь данные живут, пока мы работаем над конкретной задачей (отметкой).

    groupStudentsProvider (Список студентов группы)

        Когда загружается:

            ВАЖНО: Он загружается ДО перехода на экран отметки.

            Это происходит в HomeContentScreen внутри onPressed кнопки "Отметить".

            Код: ref.read(...).loadGroupStudents(...) -> затем context.go(...).

        Когда очищается:

            При вызове .clear().

            В твоем коде перед загрузкой новых данных (loadGroupStudents) мы делаем state = [], чтобы сбросить старый список.

    lessonAttendanceMarkProvider (Галочки: Присутствует/Отсутствует)

        Когда инициализируется:

            Внутри экрана AttendanceMarkScreen.

            Там есть проверка: if (attendanceList.isEmpty) ... initializeAttendance(...). Это создает "чистый" список галочек на основе списка студентов.

        Когда обновляется:

            При каждом нажатии цветной кнопки.

        Когда очищается (СБРОС):

            В методе saveAttendance() (после успешной отправки в Supabase).

            Код: state = [];. Это критически важно, чтобы при следующем входе список был пустым и инициализировался заново.

4. «Самоуничтожающиеся» (Чат)

Здесь используется магия Riverpod: .autoDispose.

    chatMessagesProvider

        Определение: StateNotifierProvider.autoDispose(...)

        Когда создается/загружается:

            В момент, когда ты открываешь экран чата. Срабатывает конструктор и запускается _loadInitialMessages (и подписка на стрим/поллинг).

        Когда умирает (ОЧИЩАЕТСЯ):

            АВТОМАТИЧЕСКИ, как только ты нажимаешь кнопку "Назад" и уходишь с экрана чата.

            Riverpod сам понимает, что экран закрыт, отписывается от стрима и удаляет все сообщения из памяти. При следующем входе всё начнется с нуля.